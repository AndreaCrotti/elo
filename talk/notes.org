#+AUTHOR: Andrea Crotti (@andreacrotti)
#+TITLE: Build an ELO platform with Clojure and Re-Frame
#+OPTIONS: num:nil toc:nil ^:nil tex:t reveal_progress:t reveal_control:t reveal_overview:t
#+REVEAL_TRANS: none
#+REVEAL_SPEED: fast
#+REVEAL_HLEVEL: 1
#+TOC: listings

* Play

#+BEGIN_NOTES

Playing with your colleagues is a great way to have fun at work, bond
on a more personal level with your collegues, and relax your brain for
a moment from that nasty problem you are debugging.

However of course playing is even more fun if you make it a proper
competition, with a proper league and such.

I've had internal leagues for table tennis and similar office sports
in various companies, where the tracking tool was sometimes just an
extremely complicated spreadsheet, and since there wasn't nothing here
at funding circle currently I just decided to build a new tool.

This talk is about the journey of building such platform using Clojure
full stack, but first let's explain what ELO means, and why I chose
that.

#+END_NOTES

#+BEGIN_QUOTE
All work and no play makes
Jack a dull boy
#+END_QUOTE

[[./competitivekid.jpg]]

* Elo

[[./arpad_elo.jpeg]]

#+BEGIN_NOTES

The Elo rating system is a method for calculating the relative skill
level of players in zero-sum games such as Chess.

To clarify a *zero-sum* game is simply a game where one player wins
and another player loses, or they draw, which is really almost every
game you can play in the office

In practice the rating system just works by to first assigning initial
rankings to players and then for each game compute the new rankings of
the two players.

The biggest the difference in rankings the bigger will be the changes
to the rankings.

#+END_NOTES

*The Elo rating system is a method for calculating the relative skill levels of players in zero-sum games such as chess.*

** Minor demo time

#+BEGIN_NOTES

Let's see in practice how this looks like with a simple example.

#+END_NOTES

** Elo scores example

#+BEGIN_NOTES

You can compute the new rankings of two players with simply the current rankings and the result of the game.
Everyone starts from 1500, and overall that will always be the average of all the scores in the league.

#+END_NOTES

*A: 1500, B: 1500*

$E\_A =  \frac{1}{1 + 10 ^ \frac{RB - RA}{400}} = \frac{1}{1 + 10 ^ \frac{0}{400}}$
$E\_A = \frac{1}{2} = 0.5$
$E\_B = \frac{1}{2} = 0.5$

*A vs B (3-0):*

$R\_A = 1500 + (K * (1 - E\_A)) = 1500 + (32 * (1 - 0.5)) = 1516$
$R\_B = 1500 + (K * (1 - E\_B)) = 1500 + (32 * (0 - 0.5)) = 1484$

*A = 1516, B = 1484*

** Second example

A: 1350
B: 1650

$E\_A =  \frac{1}{1 + 10 ^ \frac{RB - RA}{400}} = \frac{1}{1 + 10 ^ \frac{300}{400}}$
$E\_A = \frac{1}{6.62} = 0.15$
$E\_B = 1 - E\_A = 0.85$

*Big upset, A winning against B*

$R\_A = 1500 + (K * (1 - E\_A)) = 1500 + (32 * (1 - 0.15))$
$R\_A = 1527$

$R\_B = 1500 + (K * (1 - E\_B)) = 1500 + (32 * (1 - 0.85))$

*Draw between A and B*

$R\_A = 1500 + (K * (1 - E\_A)) = 1500 + (32 * (0.5 - 0.15))$
$R\_A = 1511$

** Elo implementation

#+BEGIN_SRC clojure
(defn expected
  [diff]
  (/ 1.0 (inc (Math/pow 10 (/ diff 400)))))

#+END_SRC

#+BEGIN_SRC clojure
(defn new-rating
  [old expected game]
  (+ old (* k (- game expected))))

#+END_SRC

#+BEGIN_SRC clojure

(defn new-rankings
  [rankings [p1 p2 score]]

  (let [ra (get rankings p1)
        rb (get rankings p2)]

    (assoc rankings
           p1 (new-rating ra
                          (expected (- rb ra))
                          score)

           p2 (new-rating rb
                          (expected (- ra rb))
                          (invert-score score)))))

#+END_SRC

* Clojurescript

#+BEGIN_NOTES

Given you are all part of a Clojure group I probably don't have to go
much into detail in Clojure.

Clojure is a great language as we all know, but maybe the greatest
advantage for me at the moment compared to most other languages is
that we also have Clojurescript, which means you can truly create a
web-app using *only* Clojure full-stack, using the JVM in the backend
and compiling Javascript for the frontend.

Clojurescript is maintained by the same guys maintaining Clojure so
it's not just a random spin-off diverging from the official language,
but actually given how the release cycle works Clojurescript all the
updates before Clojure itself does.

#+END_NOTES

- *full stack* Clojure development
- fully supported by the Clojure maintainers

* Re-frame

#+BEGIN_NOTES

Another very important piece of the puzzle is Re-Frame, which is a
great little framework to create SPAs doing Functional Reactive
Programming for real.

It uses Reagent underneath which is just a wrapper around react, so
whenever you create a re-frame app will eventually become a react
application.

#+END_NOTES

React → Reagent → Re-Frame

** Re-frame architecture

[[./reframe_dominoes.png]]

* Main advantages

# TODO: should this be here or maybe in the conclusions of the talk?

- 1 language to rule them all
- FRP rocks
- auto reloading everything

* Demo Time

#+BEGIN_NOTES

We are going to do a quick demo now, to show what it means to do full
stack development with Clojure and re-frame.  So we'll add a simple
new feature to our platform, simply showing some extra stats in the
player page.

To do this we'll need:

- one extra reagent component
- a re-frame subscription
- more business logic to compute the desired stats
- a bit of CSS to make it look pretty

#+END_NOTES

* Conclusions

*Frontend development is fun again*

* Tasks
** TODO add something about CLJC files and how easy is to share business logic across frontend and backend?
** TODO add the sample ELO implementation code
** TODO add some graph explaining how re-frame works?
** TODO think about what can be done in a small demo
** TODO add some motivation to work on this specific project

* References
- http://doctoranddad.com/kid-becoming-competitive/
